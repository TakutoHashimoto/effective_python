# 内包表記とジェネレータ
## 27. `map` や `filter` の代わりにリスト内包表記を使う
### Summary
* リスト内包表記は、`lambda` 式を必要としないので、組み込み関数の `map` や `filter` よりも明確だ。
* リスト内包表記は、入力リストから要素を抜き出すのが容易であり、これは、`filter` の助けがなければ `map` で行えない。
* 辞書と集合も内包表記を使って作成できる。


## 28. 内包表記では、3つ以上の式を避ける
### Summary
* 内包表記は、多重ループと1つのループに複数の条件をサポートする。
* 3つ以上の式を使う内包表記は、読むのが難しく、避けるべきだ。


## 29. 代入式を使い内包表記での繰り返し作業をなくす
### Summary
* 代入式により、内包表記とジェネレータ式で内包表記の条件部分の値を利用でき、読みやすさと性能が向上する。
* 内包表記やジェネレータ式の条件部分以外で代入式を使うこともできるが、避けるべきだ。


## 30. リストを返さずにジェネレータを返すことを考える
### Summary
* ジェネレータを使うと、格納した結果をリストで返すよりも、コードが明確になる。
* ジェネレータが返すイテレータは、ジェネレータ関数の本体で `yield` 式に渡される一連の値を生成する。
* ジェネレータでは、作業メモリにすべての入出力を保持する必要がないので、任意の長さの入力に対しても出力のシーケンスを生成できる。


## 31. 引数に対してイテレータを使うときには確実さを優先する
### Summary
* 入力引数を複数回反復処理する関数やメソッドに気を付ける。引数がイテレータなら、奇妙な振る舞いや欠損値に出会うかもしれない。
* Pythonのイテレータプロトコルは、コンテナとイテレータとが、組み込み関数 `iter` や `next`、`for` ループ、および関連する式でどのように働くかを定義する。
* `__iter__` メソッドをジェネレータとして実装することにより、自分のイテラブルなコンテナ型を簡単に実装できる。
* 値が（コンテナではなく）イテレータであることを、それを再度 `iter` の引数として与えても同じ結果になるかどうかで検出できる。また、組み込み関数 `isinstance` を使って、オブジェクトが `collection.abc.Iterator` かどうかをチェックできる。


## 32. 大きなリスト内包表記にはジェネレータ式を考える
### Summary
* リスト内包表記は、大量の入力に対してメモリを使いすぎるという問題を引き起こす。
* ジェネレータ式は、イテレータとして出力を1つずつ生成するので、メモリ問題を回避する。
* ジェネレータ式は、ジェネレータ式から得られたイテレータを他のジェネレータの `for` 部分式に渡すことによって、組み合わせることができる。
* ジェネレータ式は、連鎖的に組み合わせると、非常に速く動作する。


## 33. `yield from` で複数のジェネレータを作る
### Summary
* `yield from` 式により、複数の入れ子になったジェネレータを組み合わせて1つのジェネレータにできる。
* `yield from` 式により、複数の入れ子ジェネレータを使うよりも性能の良い出力ができる。


## 34. `send` でジェネレータにデータを注入するのは避ける
### Summary
* `send` メソッドを使うと、`yield` 式に与えた値を変数に代入できるようジェネレータにデータを入力できる。
* `send` と `yield from` 式を一緒に使うと、ジェネレータの出力に `None` 値が思いがけない場所に出現するようなこもった振る舞いになる。
* 組み合わせたジェネレータに入力イテレータを与えるほうが、回避すべき `send` メソッドを使う方式よりも良い。


## 35. ジェネレータで `throw` による状態遷移を起こすのは避ける
### Summary
* `throw` メソッドは、ジェネレータ内で、最も最近に実行された `yield` 式の位置で例外を再送出するために使える。
* `throw` を使うと、例外を送出したり捕捉したりするために入れ子が深くなるので、読みやすさが損なわれる。
* ジェネレータでより良い例外処理を行うためには、`__iter__` メソッドと例外の状態遷移を起こすメソッドを実装するクラスを使う方が良い。


## 36. イテレータとジェネレータの作業では `itertools` を使う
### Summary
* イテレータとジェネレータを扱う `itertools` 関数には、次の3種類がある。
  * イテレータを繋げて使う
  * 要素をふるい分ける。
  * 要素の組み合わせを作る。
* `help(itertools)` のドキュメントには、他にも高度な関数、追加パラメータ、役に立つレシピがある。
