# クラスと継承
## 37. 組み込み型の深い入れ子にはせずにクラスを作成する
### Summary
* 値が他の辞書や長いタプルや他の組み込み型の複雑な入れ子である辞書は作らない。
* 完全なクラスの柔軟性が必要となる前は、軽量で変更不能なデータコンテナである `namedtuple` を使う。
* 内部状態辞書が複雑になったら、記録管理コードを複数のヘルパークラスを使うように変更する。


## 38. 単純なインタフェースにはクラスの代わりに関数を使う
### Summary
* Pythonのコンポーネント間の単純なインタフェースは、クラスを定義してインスタンス化しなくても、大抵は関数で済ませられる。
* Pythonでは関数とメソッドの参照はファーストクラスなので、他の型同様、式中で使うことができる。
* 特殊メソッド `__call__` メソッドを使用すると、クラスのインスタンスをPythonの普通の関数として呼び出すことが可能になる。
* 状態を保守するために関数が必要な場合、状態を持つクロージャを定義する代わりに、`__call__` メソッドを提供するクラスを定義することを考える。


## 39. `@classmethod` ポリモルフィズムを使ってオブジェクトをジェネリックに構築する
### Summary
* Pythonは、クラスに対して、`__init__` メソッドという1つのコンストラクタしかサポートしていない。
* クラスに対して、代わりのコンストラクタを定義するために `@classmethod` を使う。
* 具象サブクラスを作成して連携するジェネリックな方式を提供するには、クラスメソッドポリモルフィズムを使う。


## 40. `super` を使ってスーパークラスを初期化する
### Summary
* Pythonの標準メソッド解決順序（MRO）は、スーパークラスの初期化順序とダイヤモンド継承の問題を解消する。
* スーパークラスを初期化するには、組み込み関数 `super` を引数なしで使う。


## 41. Mix-inクラスで機能合成を考える
### Summary
* インスタンス属性や `__init__` メソッドを持つようなクラスの多重継承は避け、可能ならmix-inを使う。
* インスタンスレベルではプラグイン可能な振る舞いを使い、mix-inクラスが必要なときに、クラスごとにカスタマイズする。
* mix-inは、必要性に応じて、インスタンスメソッドまたはクラスメソッドを含められる。
* 単純な振る舞いから複雑な機能を構成するようにmix-inを組み合わせて作る。


## 42. プライベート属性よりパブリックな属性が好ましい
### Summary
* プラーベート属性は、Pythonコンパイラが厳密に強化して強制しているものではない。
* サブクラスを締め出すのではなく、内部APIと属性を利用できるように最初から考慮しておくこと。
* プライベート属性でアクセスするのは避け、保護フィールドについてドキュメンテーションで説明してサブクラスを使う。
* プライベート属性では、コントロール外のサブクラスによる名前衝突を避けるためだけに考慮する。


## 43. カスタムコンテナ型は `collection.abc` を継承する
### Summary
* 単純なユースケースでは、（`list` や `dict` のような）Pythonのコンテナ型から直接継承する。
* カスタムコンテナ型を正しく実装するには多数のメソッドが必要なことに注意する。
* 作ったクラスが必要なインタフェースと振る舞いを備えていることを確かなものにするために、カスタムコンテナ型は `collection.abc` で定義されたインタフェースを継承する。

